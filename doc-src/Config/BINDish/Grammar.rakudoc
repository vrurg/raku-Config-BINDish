=begin pod
=head1 NAME

C<Config::BINDish::Grammar> - the central class of everything in C<Config::BINDish>

=head1 DESCRIPTION

This class is responsible for the actual parsing of the configuration. It is not recommended for direct use.
L<C<Config::BINDish>|../BINDish.md>
C<read> method must be used instead.

The class inherits from the standard L<C<Grammar>|https://docs.raku.org/type/Grammar> class.

=head1 ATTRIBUTES

Some attributes are declared with help of L<C<AttrX::Mooish>|https://modules.raku.org/dist/AttrX::Mooish>.
For C<lazy> attributes it means that method C<build-attribute-name> is used to get the initial value. These methods
can be overridden by extensions if necessary.

=head3 L<C<Bool:D>|https://docs.raku.org/type/Bool> C<$.flat>

If set this attribute expects blocks to be flattened down. I.e. whenever a block has a duplicate declaration in the
config the later declaration must be applied on top of the first one. This doesn't change grammar's behavior but rather
serves as a note for the actions class to take care of the situation. One way or another, if this attribute is I<True>
then the user expects a single block C<foo "bar"> representation to exists after the following sample is parsed:

    foo "bar" { fubar 1; }
    baz { }
    foo "bar" { fubar 2; fubaz 3.14; }

How the options are dealt with is the sole prerogative of the actions implementation.
L<C<Config::BINDish::Actions>|Actions.md>
re-delegates handling of flattening to the underlying
L<C<Config::BINDish::AST>|AST.md> class.
It, in turn, will overwrite earlier option declarations with latter ones. So, when one queries for C<fubar> the value
returned will be I<2>.

See L<$*CFG-FLAT-BLOCKS|#$*CFG-FLAT-BLOCKS>.

=head3 L<C<Config::BINDish::Grammar::Strictness>|Grammar/Strictness.md> C<$.strict = False>

Defines what strictness modes are activated. See
L<C<Config::BINDish::Grammar::Strictness>|Grammar/Strictness.md>.

=head3  C<@.prop-keys>

I<Lazy>. Defines the types of statements supported by pre-declaration. Currently it is set to I<block> and I<option>.
But extensions can add their own types via overriding C<build-prop-keys> method.

=head3 L<C<Hash>|https://docs.raku.org/type/Hash>C<[>L<C<Config::BINDish::Grammar::StatementProps:D>|Grammar/StatementProps.md>C<]> C<%.props>

I<Lazy>. Registry of all pre-declared statement properties. The first level keys of the hash are values in 
C<@.prop-keys>, the second level keys are statement IDs.

=head3 L<C<SetHash>|https://docs.raku.org/type/SetHash> C<%.keywords>

I<Lazy>. Registry of all registered keywords. Keys are the values in C<@.prop-keys>. Values are C<SetHash>'es of
pre-declared keywords. The purpose of the attribute is to let code know if a keyword is used by a pre-declaration.

=head3  C<%.prop-relations>

I<Lazy>. First level keys are IDs of blocks ever mentioned with C<in> key in statement pre-declaraions. For example:

    Config::BINDish.new: blocks => ( :srv-cloud<service> => { ... },
                                     :srv-local<service> => { ... }
                         ),
                         options => ( :loc-url<location> => { :in<srv-cloud> } );

C<srv-cloud> will become a key on C<%.prop-relations>, contrary to C<srv-local> which is not referenced by any
pre-declaration.

The second level keys are types listed in C<@.prop-keys>.

The third level keys of the hash are keywords allowed in the block. In the above example there will be just one key:
C<location> under C<option>. It's value will be properties object of the option with ID C<loc-url>.

Note that the keyword, not the ID, is used in this case. This is because a keyword must be unique per block per
statement type. I.e. we can have a block C<location>, and an option C<location>. But we can't have two different
C<location> options.

=head3 L<C<Pair:D>|https://docs.raku.org/type/Pair> C<@.blocks>

List of user-defined blocks. Passed to C<declare-blocks> method at object construction time.

See
L<C<Config::BINDish::Grammar::BlockProps>|Grammar/BlockProps.md>
and L<#Pre-declaration> section for more information.

=head3 L<C<Pair:D>|https://docs.raku.org/type/Pair> C<@.options>

List of user-defined options. Passed to C<declare-options> method at object construction time.

See
L<C<Config::BINDish::Grammar::OptionProps>|Grammar/OptionProps.md>
and L<#Pre-declaration> section for more information.

=head3  C<%.reserved-opts>

Keys of this hash are names of options which are reserved for C<Config::BINDish> own use. An extension module can add
more keys to the hash if it needs to.

=head3 Int:D C<$.line-delta = 0>

Contains the delta to be subtracted from the actual line number when it is reported to the user. For example, if set to
2 and the actual location is at line 10 then the user will be reported with number 8. Used by C<#line> directive.

=head1 DYNAMIC VARIABLES

The grammar declares and uses a set of dynamic variables to pass certain information between its rules, tokens, methods,
and the actions object.

=head3 C<$*CFG-GRAMMAR>

The primary grammar object. Due to the way the L<C<Grammar>|https://docs.raku.org/type/Grammar> is implemented C<self> does not always point to the same
object created by the initial C<parse> method. These instances are not full clones of the original grammar and do not
inherit all attribute values from it. For this reason when access to the user-set attributes is needed the original
grammar is better be easily available.

=head3 C<$*CFG-CTX>

Current block or option context.

=head3 C<$*CFG-PARENT-CTX>

Parent block context.

=head3 C<$*CFG-AS-INCLUDE>

If set to I<True> then it means that the current grammar is parsing included source.

=head3 C<$*CFG-FLAT-BLOCKS>

Set to C<$.flat> attribute value.

=head3 C<$*CFG-INNER-PARENT>

Provided for actions convenience. Intended to hold an instance of
L<C<Config::BINDish::AST::Node>|AST/Node.md>.

=head3 C<$*CFG-TOP>

Provided for actions convenience. Intended to hold an instance of
L<C<Config::BINDish::AST::TOP>|AST/TOP.md>.

=head3 L<C<Config::BINDish::Grammar::Value>|Grammar/Value.md> C<$*CFG-VALUE>

Must be provided directly or indirectly by any rule or token invoking the C< <value>> token. This variable will be set to a
L<C<Config::BINDish::Grammar::Value>|Grammar/Value.md>
instance created by C<set-value> method.

=head3 L<C<Config::BINDish::Grammar::Value>|Grammar/Value.md> C<$*CFG-KEYWORD>

Set by C< <keyword>> token. The value stored will be of type L<C<Str>|https://docs.raku.org/type/Str> and have type name
I<"keyword">.

=head3 C<$*CFG-BLOCK-TYPE>, C<$*CFG-BLOCK-NAME>, C<$*CFG-BLOCK-CLASS>

All three are of
L<C<Config::BINDish::Grammar::Value>|Grammar/Value.md> type.
When the following example is parsed:

    foo "bar" baz { }

The variables will be set to:

=item type: "foo" of L<C<Str>|https://docs.raku.org/type/Str>, type-name I<"keyword">
=item name: "bar" of L<C<Str>|https://docs.raku.org/type/Str>, type name I<"dq-string">
=item class: "baz" of L<C<Str>|https://docs.raku.org/type/Str>, type name I<"keyword">

Note that the name could be of any value, supported by the grammar. If an extension adds a new value type then the
type can also be used as a type name. Say, with
L<C<Config::BINDish::INET>|INET.md>
loaded one can have the following valid declaration:

    IP 192.168.1.42 { }

For which the name will be set to type C<IP::Addr>, type-name I<"IPv4">.

=head3 C<$*CFG-BLOCK-ERR-POS>

This variable is set to a L<C<Match>|https://docs.raku.org/type/Match> object pointing at the location where current
block declaration starts. Can be used for error reporting.

=head3 C<$*CFG-SPECIFIC-VALUE-SYM>

Set by the grammar whenever a specific value type is expected. See more details in L<#value-sym> section below.

=head3 C<$*CFG-BACKTRACK-OPTION>, C<$*CFG-BACKTRACK-BLOCK>

These variables are set by corresponding C<backtrack-*> method to indicate the context in which C<leave-*> methods are
called. In other words, if C<!$*CFG-BACKTRACK-OPTION> is I<True> when C<leave-option> is invoked then an option has been
successfully parsed.

=head1 METHODS

=head3 C<set-value(Mu \type, *%value)>

This methods creates a new
L<C<Config::BINDish::Grammar::Value>|Grammar/Value.md>
object and assigns it to C<$*CFG-VALUE>. Takes value's type object as its single positional parameter. Type name and
payload are passed as the only named argument of the method call. Here is how a single-quoted string is handled by
the grammar:

    token sq-string {
        \' ~ \' $<string>=<.qstring("'")>
        {
            self.set-value: Str, :sq-string($<string>)
        }
    }

In this example the new
L<C<Config::BINDish::Grammar::Value>|Grammar/Value.md>
object will be created with payload set from C<$<string>>, type name set to I<"sq-string">, and type set to
L<C<Str>|https://docs.raku.org/type/Str>.

=head3 C<set-line-relative(Int:D $from-line, Int:D :$to-line = self.line(:absolute))>

Sets C<$.line-delta> as a difference between C<$from-line> to C<$to-line> so that, when a line number is reported at
some point in time after a call to this method, the user will see C<$reported-line - ($to-line - $from-line + 1))>.

=head3 C<set-file($file)>

Sets the file name to be reported to the user in messages.

=head3 C<file()>

Returns file name to be reported in messages.

=head3 C<line(Bool :$absolute = False)>

Returns either a line number to be reported in messages; or the absolute line number of the currently parsed buffer.

=head3 C<submethod setup-BINDish>

When the grammar is instantiated it iterates over all of its parents and roles and invokes each unique C<setup-BINDish>
submethod it finds. While it may seem to look as a duplicate of C<TWEAK>, the purpose of using this approach is to
eliminate the differences in handling of submethods by Raku versions 6.c/d and 6.e.

See also L<#Pre-declaration> section.

=head3 C<multi reserve-keywords(Str:D $what, @keywords)>
=head3 C<multi reserve-keywords(*%what-keywords)>

Registers a list of keywords as reserved. C<$what> is statement type for which keywords are registered; must be one of
C<@.prop-keys> values.

    $*CFG-GRAMMAR.reserve-keywords: "option", <foo bar>;
    $*CFG-GRAMMAR.reserve-keywords: option => <foo bar>,
                                    block  => <bar baz>;

=head3 C<multi is-reserved(Str:D $what, Str:D $keyword)>
=head3 C<multi is-reserved(*%p where *.elems == 1)>

Returns I<True> is C<$keyword> is registered for statement type C<$what>. The second for is a convenience one, it
accepts only a single named parameter with name being the statement type. The following two line are equivalent:

    $*CFG-GRAMMAR.is-reserver: 'option', 'foo';
    $*CFG-GRAMMAR.is-reserver: :option<foo>;

=head3 C<proto statement-props(Str:D $what)>

Returns pre-declaration properties class depending on the value of C<$what>. The candidates provided by the core only
support I<'option'> and I<'block'> and return
L<C<Config::BINDish::Grammar::OptionProps>|Grammar/OptionProps.md>
or L<C<Config::BINDish::Grammar::BlockProps>|Grammar/BlockProps.md>
respectively. An extension can add own candidate if it introduces additional statement type.

=head3 C<declare-statement(Str:D $what, Any:D $id = self.autogen-id, $keyword where Str:D | Bool, :%props, Bool :$cleanup = True)>

This is a low-level statement pre-declaration registration method. It creates a properties object with the
class returned by C<statement-props> method for statement type C<$what> and using C<%props> as constructor
initialization profile. C<$id> and C<$keyword> are also used as initialization profile keys.

If C<$keyword> parameter is a L<C<Bool>|https://docs.raku.org/type/Bool> value then it is set to C<$id> value. This is done to provide support for
C<:foo => { ... }> pre-declaration syntax where C<:foo> represents both ID and keyword.

Parameter C<$cleanup> specifies if C<$.prop-relations> attribute must be reset and rebuilt. It is unlikely a user
would ever need it to be I<False>.

=head3 C«multi declare-block(Any:D $id, Str:D $keyword, %props, Bool :$cleanup = True --> BlockProps:D)»
=head3 C«multi declare-block(Any:D $id, Str:D $keyword, Bool :$cleanup = True, *%props --> BlockProps:D)»
=head3 C«multi declare-block(Pair:D $identity, %props, Bool :$cleanup = True --> BlockProps:D)»
=head3 C«multi declare-block(Str:D $keyword, %props, Bool :$cleanup = True --> BlockProps:D)»
=head3 C«multi declare-block(Str:D $keyword, Bool :$cleanup = True, *%props --> BlockProps:D)»
=head3 C«multi declare-block(*%params --> BlockProps:D)»

This method registers a single block. Parameters:

=item C<$id> – block ID
=item C<$keyword> – block keyword
=item C<$identity> - a L<C<Pair>|https://docs.raku.org/type/Pair> where the key is C<$id>, and the value is C<$keyword>
=item C<%props> – hash of block properties; see L<#Pre-declaration>
=item C<$cleanup> – see C<declare-statement> method
=item C<%params> - hash of named parameters for C<declare-statement>

Basically, all this method does it turns its parameters into named arguments for C<declare-statement> and calls it
as C<self.declare-statement('block', |%params)>.

=head3 C«multi declare-blocks(@blocks, Bool :$cleanup = True --> Nil)»
=head3 C«multi declare-blocks(%blocks, Bool :$cleanup = True --> Nil)»

Pre-declare blocks. C<@blocks> is expected to be a list of L<C<Pair>|https://docs.raku.org/type/Pair> objects,
as explained in L<#Pre-declaration> section.

=head3 C«multi declare-option(Any:D $id, Str:D $keyword, %props, Bool :$cleanup = True --> OptionProps:D)»
=head3 C«multi declare-option(Pair:D $identity, %props, Bool :$cleanup = True --> OptionProps:D)»
=head3 C«multi declare-option(Str:D $keyword, %props, Bool :$cleanup = True --> OptionProps:D)»
=head3 C«multi declare-option(Str:D $keyword, Bool :$cleanup = True, *%props --> OptionProps:D)»
=head3 C«multi declare-option(*%params --> OptionProps:D)»

This method registers a single option. Parameters:

=item C<$id> – option ID
=item C<$keyword> – option keyword
=item C<$identity> - a L<C<Pair>|https://docs.raku.org/type/Pair> where the key is C<$id>, and the value is C<$keyword>
=item C<%props> – hash of option properties; see L<#Pre-declaration>
=item C<$cleanup> – see C<declare-statement> method
=item C<%params> - hash of named parameters for C<declare-statement>

Basically, all this method does it turns its parameters into named arguments for C<declare-statement> and calls it
as C<self.declare-statement('option', |%params)>.

=head3 C<multi declare-options(@options)>
=head3 C<multi declare-options(%options)>

Pre-declare options. C<@options> is expected to be a list of L<C<Pair>|https://docs.raku.org/type/Pair> objects,
as explained in L<#Pre-declaration> section.

=head3 C<autogen-id()>

Returns a unique string to be used as a statement identifier.

=head3 C<enter-ctx(Value:D :$keyword, Str:D :$type, *%profile)>

Creates a new
L<C<Config::BINDish::Grammar::Context>|Grammar/Context.md>
object. Returns the new context, which is also stored into C<$*CFG-CTX>.

This method expects C<$*CFG-PARENT-CTX> to be set to the parent context instance, and C<$*CFG-CTX> to be undefined.
Normally a rule which plans to create a new context must have the following two lines in it:

    :my Context:D $*CFG-PARENT-CTX = $*CFG-CTX;
    :temp $*CFG-CTX = Nil;

Method throws C<Config::BINDish::X::Parse::ContextOverwrite> if C<$*CFG-CTX> is already set.

If C<id> key in C<%profile> is undefined then the method tries to guess it based on the C<$keyword>. If it has at least
one pre-declaration (i.e. it is recorded in C<%.keywords>), then its properties are looked up either on enclosing
block, or on C<.ANYWHERE> block (see C<%.prop-relations>). If neither lookup succeeds then it is assumed that the
keyword cannot be used in the current block and C<Config::BINDish::X::Parse::Context> is thrown.

If the C<$keyword> is not pre-declared then the method uses C<autogen-id> method to produce a new unique ID for the
statement. Note that for two subsequent statements of the same type used within the same block two different IDs would
be produced in this case.

=head3 C<backtrack-option()>

A callback method invoked by C«statement:sym<option>» rule if it fails to parse a keyword statement as an option. This
does not necessarily mean that there was a syntax error in the configuration source. It could be just a normal
backtracking.

Set C<$*CFG-BACKTRACK-OPTION> to I<True> and invokes C<leave-option> method.

=head3 C<backtrack-block()>

Similar to C<backtrack-option> method above but for block declarations.

Sets C<$*CFG-BACKTRACK-BLOCK> to I<True> and invokes C<leave-block> method.

=head3 C<leave-option()>

Invoked when leaving option context.

=head3 C<leave-block()>

Invoked when leaving block context.

=head3 C<validate-option()>

Validates currently being parsed option based on its keyword. Uses pre-set variables
L<C<$*CFG-KEYWORD>|#$*CFG-KEYWORD> and L<C<$*CFG-VALUE>|#$*CFG-VALUE>.

Can throw one of
L<C<Config::BINDish::X::Parse::Context>|X/Parse/Context.md>,
L<C<Config::BINDish::X::Parse::ValueType>|X/Parse/ValueType.md>,
or L<C<Config::BINDish::X::Parse::Unknown>|X/Parse/Unknown.md>.

=head3 C<validate-block()>

Validates currently being parsed block based on its keyword (type), name, and, possibly, class. Uses pre-set variables
L<C<$*CFG-BLOCK-TYPE>|#$*CFG-BLOCK-TYPE>, L<C<$*CFG-BLOCK-NAME>|#$*CFG-BLOCK-NAME>,
L<C<$*CFG-BLOCK-CLASS>|#$*CFG-BLOCK-CLASS>. If block passes the validation then a new block context is pushed onto
the context stack.

Can throw one of
L<C<Config::BINDish::X::Parse::Context>|X/Parse/Context.md>,
L<C<Config::BINDish::X::Parse::ExtraPart>|X/Parse/ExtraPart.md>,
L<C<Config::BINDish::X::Parse::MissingPart>|X/Parse/MissingPart.md>,
or L<C<Config::BINDish::X::Parse::Unknown>|X/Parse/Unknown.md>.

=head3 C<validate-value()>

Makes sure a value can be used in the current context. Uses variable L<C<$*CFG-VALUE>|#$*CFG-VALUE>.

Can throw
L<C<Config::BINDish::X::Parse::ValueType>|X/Parse/ValueType.md>.

=head3 C<multi method panic(Str:D $msg)>

Throws
L<C<Config::BINDish::X::Parse::General>|X/Parse/General.md>
with message C<$msg>.

=head3 C<multi method panic(Config::BINDish::X::Parse:U \exception, Str $msg?, *%profile)>

Creates an object of type C<exception> using C<%profile> as named arguments for constructor and throws it. If $msg
is specified then it is added to the profile as named argument C<:$msg>.

Both C<panic> methods also pass the grammar object they're invoked upon as C<cursor> named argument to provide
the exception instance with error location and other useful information.

=head3 C<include-source(IO:D(Str:D $file, Match:D $cursor --> Str:D)>

This method provides source configuration to be included with C<include> option. The default implementation tries to
read C<$file>. If it can't then either of two exceptions are thrown:

=item C<Config::BINDish::X::FileNotFound> if C<$file> doesn't exists
=item C<Config::BINDish::X::FileOp> if C<$file> is unreadable

=head1 GRAMMAR ELEMENTS

Rules and tokens listed in this section are the ones considered public API of this module. Those not listed here but
implemented by the grammar are considered implementation detail and can be changed or removed any time without prior
notice.

Description provided here would mostly be rather succinct. Checking with the grammar source is the most correct way
of understanding it.

=head2 Rules And Tokens

=head3 C<rule TOP>

See L<C<Grammar>|https://docs.raku.org/type/Grammar>.

Pushes I<"TOP"> context onto the stack and invokes C<statement-list>.

=head3 C<token enter-TOP>

Does nothing, used as anchor for
L<C<Config::BINDish::Actions>|Actions.md>.

=head3 C<rule statement-list>

Used in the global and block contexts.

=head3 C<proto statement>

Currently defined statements are (as named within C<:sym<...>> postfix):

=item comment
=item value
=item option
=item block
=item empty

=head3 C<token statement-terminator>

Matches a statement terminator. Doesn't take the current strictness mode into account and tries matching as if
non-strict syntax mode is used.

=head3 C<token statement-terminate>

A wrapper around C<statement-terminator> which validates it against the current syntax strictness mode.

=head3 C<token block-head>

Parses the block type keyword. Sets
L<C<$*CFG-BLOCK-TYPE>|#$*CFG-BLOCK-TYPE>.

=head3 C<token block-name>

Parses the block name. Sets
L<C<$*CFG-BLOCK-NAME>|#$*CFG-BLOCK-NAME>.

=head3 C<token block-class>

Parses the block name. Sets
L<C<$*CFG-BLOCK-CLASS>|#$*CFG-BLOCK-CLASS>.

=head3 C<token block-body>

Validates the block and sets the current block context.

=head3 C<C-comment>, C<CPP-comment>, C<UNIX-comment>

Three types of comments

=head3 C<keyword>

Parses a keyword which is defined as an alpha-numeric identifier starting and ending with a word boundary. Sets
L<C<$*CFG-KEYWORD>|#$*CFG-KEYWORD>.

=head3 C<token dq-string>, C<token sq-string>

Double- and single-quoted strings. The standard grammar and actions do not care about the exact nature of a string.
But extensions could adjust their behavior based on the string type. For example,
L<C<Config::BINDish::Expandable>|Expandable.md>
implements macro expansion for double-quoted strings only.

=head3 C<proto token value>

Umbrella-rule for all value types. If you plan an extension for a new value type then this is where you plug it into.

The following value types are currently implemented, listed as named within C<:sym<...>> postfix:

=item string
=item keyword
=item num
=item rat
=item int
=item bool

=head2 Named captures

Some named captures are also considered public API.

=head3 C<$<err-pos>>

Records the location to which call of method C<panic> should be bound. In other words, if the location within a rule
body where we make the decision about syntax validity is different from the location where the user would understand it
best then C<panic> should be invoked as:

    $<err-pos>.panic: Config::BINDish::X::Parse::AError, ...;

For example, we parse an option like:

    pi 3.1415926;

When all the information we need to validate it is collected our grammar points at the position right after the
terminating semi-colon. If we do C<self.panic(...)> then the error message look kind of the following:

    Option pi cannot be used in block...
      at line N
        pi 3.1415926;⏏

But with C<$<err-pos>.panic(...)> it would rather be:

    Option pi cannot be used in block...
      at line N
        ⏏pi 3.1415926;

Which certainly makes more sense to the user.

=head3 C<$<option-name>>, C<$<option-value>>

Point to parsed option name and value L<C<Match>|https://docs.raku.org/type/Match>es.

=head3 C<$<block-type>>

Points to parsed block type L<C<Match>|https://docs.raku.org/type/Match> object.

=head3 C<$<string>>

Points to actual string body of a stringy value. I.e. for I<what "The answer is 42"> this capture will be a
L<C<Match>|https://docs.raku.org/type/Match> object pointing at I<The answer is 42> part of the source, quotes excluded.

=head1 GRAMMAR OPERATION

=head2 Pre-declaration

I<DISCLAIMER. I don't like the term "pre-declaration", but fail to come up with something better so far. Ideas are
welcome!>

In the default mode of operation the grammar accepts any blocks and options in a config file as long as they adhere to
the syntax requirements. But often it is desirable to constrain the set of accepted block/option keywords. And even more
often it is necessary to restrict certain syntax rules applied to them.

For example, for options it would make sense to restrict acceptable types of their values; actually, sometimes this
applies to blocks too. For blocks we may need to specify requirements for the name and class parts to be used or not.

Another useful property of options and blocks is the context where they're allowed. By context the current grammar
assumes the current enclosing block.

Let's consider a network configuration file where we use C<host> and C<lan> blocks and some network-related options.

I<NOTE> that the following example requires
L<C<Config::BINDish::INET>|INET.md>
module to be used.

    ip 192.168.1.2; // Error, we don't know the host to apply this ip to
    lan { # Error, a LAN must be given a name
    }
    lan "office" {
        network 192.168.42.0/24;
    }
    lan 192.168.1.0/24 {
        name "Data Center";
        ip 192.168.1.13; // Error, only a host can have an address
        host "gw" {
            ip 192.168.1.1; # This is default ip on the lan
            interface "outside" {
                ip 1.2.3.4/24;
                gw 1.2.3.1;
            }
        }
    }
    host "rambler" { // Error, a host can only belong to a lan
        ip "dhcp-pool"; // Good try, but – no, this is an error too!
        free-form "with some text"; # This is an error if the option is not pre-declared and strict mode is in effect
    }

Next in this section we will find out how to tell the grammar about the constraints we'd like to apply. Keep in mind
that this section talks about options and blocks. And that any 3rd party extension module can introduce their own kinds
of statements and use their own approach to their pre-declaration.

Statement pre-declaration consist of two parts:

=item statement descriptor which consists of its globally unique ID and a keyword
=item properties defining the actual constraints

There are also two ways to pre-declare:

=item via initializing C<@.blocks> and C<@.options> attributes with lists of L<C<Pairs>|https://docs.raku.org/type/Pairs> per each statement
=item via using C<declare-> family of grammar methods

As a matter of fact, the grammar is using the attributes to eventually pass them to corresponding C<declare-blocks>
or C<declare-options> methods in C<setup-BINDish> submethod. This is also the recommended way for a 3rd party extension,
would it need to utilize pre-declaration. But from the user perspective it is preferable to use the first way:

    my $cfg = Config::BINDish.new: blocks => (...), options => (...);

=head3 Statement Pre-declaration Syntax

As it was stated before, blocks and options are pre-declared by pairs. For each L<C<Pair>|https://docs.raku.org/type/Pair>
its key is statement descriptor, and its value is a hash of statement properties. The most generic statement
pre-declaration would look like the following example:

    :id1<foo> => { :prop1(...), :prop2(...), ... }

The particular properties will be listed later in this section. For now let's focus on the descriptor.

=head3 Statement Descriptor

There is a reason for the descriptor to consist of two elements. If we consider an option, its keyword might not be
unique across config, but it can have different meaning within different blocks. Often it would mean different
value types allowed for use too:

    LAN "Data Center" {
        server "microservices.my.net" {
            location "Room C3, Rack 1234";
        }
        service "monitoring" {
            location https://nagios.local;
        }
    }

As you can see here, even though C<location> keyword is used within both C<server> and C<service> blocks, it represents
different options of which one specifies a physical location, and another is for a network location. Use of unique
IDs allows the parse to distinguish them. In terms of creating an instance of C<Config::BINDish> it would look like
this:

    my $cfg = Config::BINDish.new: ...,
                options => (
                    :loc-phys<location> => { ... },
                    :loc-url<location> => { ... }
                );

But what if we actually don't need those IDs? In this case they can be omitted:

    my $cfg = Config::BINDish.new: ...,
                options => (
                    location => { ... },
                    location => { ... }
                );

When this notation is used the grammar will auto-generate unique IDs for each statement to still be able to distinguish
one declaration from another. But C<Config::BINDish::X::DuplicateKeyword> would be thrown if we attempt to use both
variants in the same block.

Another case is when we know that statement's keyword is inherently unique. In the above example we can say this about
the C<server> and the C<service> blocks. It would be OK to use IDs which match respective keywords. To do so a boolean
L<C<Pair>|https://docs.raku.org/type/Pair> notation can be used to declare the blocks:

    my $cfg = Config::BINDish.new: ...,
                blocks => (
                    :server => { ... },
                    :service => { ... },
                );

The above is equivalent to C«:server<server>» and C«:service<service>» notations.

=head3 Statement Properties

Properties of a statement pre-declaration are specified as keys of a hash. For example, the last example of the
previous section can be written as:

    my $cfg = Config::BINDish.new: ...,
                blocks => (
                    :server => { :named },
                    :service => { :named },
                );

Detailed descriptions of each key follows.

=head4 C<in>

This key specifies a set of block IDs where use of the statement is allowed. If a block is not listed in this key
then the statement can't be used in that block.

    my $cfg = Config::BINDish.new: ...,
                blocks => (
                    :server => { :named },
                    :service => { :named },
                ),
                options => (
                    ip => { :in<server host> },
                    location => { :in<service> },
                );

With the above declaration:

    server "gw" {
        ip 192.168.42.1;
    }
    service "nagios" {
        ip 192.168.42.13; # Error, only location can be used here
        location https://nagios.local;
    }

Note how we use C<host> alongside with C<server> to pre-declare C<ip>. This is not an error as the grammar will
auto-vivify block pre-declaration for us. It will have both ID and keyword set to C<host>. We can later re-declare it
with non-default properties. If we do so the re-declaration will lost its I<auto-vivified> status and any subsequent
re-declaration will become an error.

In a little bit more complex case a block can be presented as a pair of two strings where key would still be block's
ID and the value would allow to narrow down block classes for which a declaration is allowed. In the most simple case we
can limit to a single class by its name:

    :keyword => { :in(:classy<specific>), ... }

C<keyword> would only be allowed within a C<specific> block C<classy>:

    classy "a name" specific {
        keyword ...;
    }

Since the value of block definition pair is used on right hand side of a smartmatch operator the class condition is not
only limited to strings. Consider the following examples:

    :in(:classy('specific' | 'special' | 'limited'))
    :in(:classy(/^ specif .* $/))
    :in(:classy(*.starts-with: 'specif'))

=head4 C<type>

This key allows to constrain value type which can be used for values of the statement. This key is used as RHS of
L<smartmatch|https://docs.raku.org/language/operators#index-entry-smartmatch_operator> operator.

    my $cfg = Config::BINDish.new: ...,
                options => (
                    multiplier => { :in<measurements>, :type(Num | Rat) },
                    ip => { :in<server>, type => IP::Addr },
                );

Because value validation takes place in a context where C<$*CFG-VALUE> is available, it is even possible to do things
like:

    my $cfg = Config::BINDish.new: ...,
                blocks => (
                    :srv-ph<server> => { :in<datacenter>, :named }, # A physical server
                    :srv-vm<server> => { :in<vm-cluster>, :named }, # A VM server
                ),
                options => (
                    location => { :in<srv-ph>, type => { $_ ~~ Stringy && $*CFG-VALUE.payload.contains('Rack') },
                    location => { :in<srv-vm>, type => { $_ ~~ Stringy && $*CFG-VALUE.payload.contains('Cluster') },
                );

=head4 C<type-name>

Value type name elaborates on the exact meaning of a value. For example, a value can have Raku L<C<Str>|https://docs.raku.org/type/Str> type.
But then it can be one of:

=item I<sq-string> - single-quoted string
=item I<dq-string> - double-quoted string
=item I<file-path>
=item I<keyword>

With this key one can be even more explicit as to what values are acceptable:

    my $cfg = Config::BINDish.new: ...,
                options => (
                    location => { :in<srv-ph>, type => { $_ ~~ Stringy && $*CFG-VALUE.payload.contains('Rack') },
                    location => { :in<srv-vm>, type => { $_ ~~ Stringy && $*CFG-VALUE.payload.contains('Cluster') },
                    location => { :in<pdf-collection image-collection>, :type(Str), :type-name<file-path> }
                );

With this declaration the following config is incorrect:

    pdf-collection "user uploads" {
        location "/mnt/cloud-data/uploads/pdf"
    }

Yet, same as with the C<type> key, C<type-name> is used as smartmatch operator RHS. Therefore if we replace it with:
C«:type-name(/^ [ "file-path" | .. "-string" ] $/)» or C«:type-name(any <file-path sq-string dq-string>)» – then the
above snipped will become valid.

=head4 C<value-sym>

This key defines an exact list of allowed grammar rules/tokens of C«value:sym<...>» candidates to be tried when a value
is parsed. The list must contain the words used between C«< >» symbols of C<:sym> adverb. I.e. for the C<multiplier>
option from a previous example we can explicitly make the grammar even don't attempt matching on anything but the
numeric values:

    multiplier => { :value-sym<num rat int>, ... }

With this pre-declaration the grammar will attempt only tokens C«value:sym<num>», C«value:sym<rat>», C«value:sym<int>».
In this case the following example will throw with C<Config::BINDish::X::Parse::General> instead of
C<Config::BINDish::X::Parse::ValueType>:

    multiplier "3.1415926";

When the grammar iterates over C<value-sym> items it sets C<$*CFG-SPECIFIC-VALUE-SYM> dynamic to the currently attempted
item. This allows the candidate token to know that it is being expected to succeed and some additional measures could be
taken to fulfill the expectations.

For example, if we expect an option to be a file system path then the following example is likely not to parse correctly
because the value can be considered both a keyword or a single path element:

    pathy etc;

For this reason C«value:sym<file-path>» candidate does not attempt parsing something as a path unless it finds a slash
separator. I.e. for the above example to work it must look like:

    pathy /etc;

or

    pathy etc/;

But if we pre-declare the option like:

    pathy => { :value-sym<file-path>, ... }

Then C«value:sym<file-path>» would know that C<etc> would not be tried as a keyword and it can safely consider it a
file/directory name.

=head4 C<named>

Block-only key. If I<True> then block must have a name. If I<False> then block must not be named. Omitting this key
allows the name to be optional.

=head4 C<classified>

Block-only. Similar to C<named> but for block class. Only makes sense if C<named> is true or optional and block
name is specified. Otherwise this key is ignored.

=head4 C<value-only>

Block-only. If this key is set to I<True> then the block can not contain options, only values are allowed. I.e. with
a declaration like:

    foo => { :value-only }

The following config would be an error:

    foo { option 42 }

But the following example will work:

    foo { 13; 42; 3.1415926 }

Note that within a value-only block keywords are treated as keyword values, not as boolean options:

    foo { value1; value2 } # Two string values with type name 'keyword'
    bar { value1; value2 } # Two True options because bar is not pre-declared

Here is an example of how this peculiarity can be used:

    acl office { 192.168.42.0/24; 192.168.13.0/24 }
    acl data-center { 10.42.0.0/16 }
    acl customers { 172.10.0.0/16 }
    acl any { 0.0.0.0/0 }
    network "internal" {
        access-rules {
            allow { office; data-center } # 'allow' is a value-only block
            disable { any }; # value-only block too
        }
    }
    network "public" {
        access-rules { allow { any } }
    }

=head4 C<no-values>

Block-only. This property is a direct opposite to C<value-only> as blocks declared with it can not hold any values.
So, a declaration like this:

    foo => { :no-values }

will cause the following to throw:

    foo { "bar"; }

Since the property is clearly conflicting with C<value-only> use of both within a block declaration will result in an
exception thrown.

=head4 C<default>

Specifies the default value of a statement. When used with a block declaration then multiple values can be used.

    blocks => (
        :server => %( :in<.TOP> ),
        :services => %( :default<api login files>, :type(Str), :in<server> ),
    ),
    options => (
        :server-iface<interface> => { :type(Str), :default<*>, :in<server> },
        :server-port<port> => { :type(Int), :default(80), :in<server> },
    )

Default values are not verified against pre-declaration C<type> constrain.

=head4 C<where>

This property meaning is the same, as L<C<where>|https://docs.raku.org/type/Signature#Type_constraints> clause in Raku:
it defines a constraint on the allowed values. The property is used as smartmatch RHS. Consider the examples:

    foo => { :type(Int), :where(* > 10) }
    bar => { :type(Str), :where(any <debug info error>) }

B<Note> that similar outcome could be achieved by using a
L<C<subset>|https://docs.raku.org/language/typesystem#index-entry-subset-subset> with C<type> property. But C<where>
is more obvious on many occasions.

=head4 C<why>

This property must be a short string to be used within error message of the exception thrown when C<where> constraint
is not met. For example, if there is an option declaration:

    min => { :type(Int), :where(* >= 10), :why('must be 10 or more') }

Then defining the option as C<min 1;> in a configuration file would produce output similar to the following:

    Option 'min' expects a (Int) value (must be 10 or more) but got 1
      at line 2
        ⏏min 1;

=head3 Reservations

=head4 Names

All keywords and IDs starting with a dot are reserved for internal use. Any use of dot-started names/IDs like I<.foo> is
discouraged.

=head4 Option And Block Keywords

The grammar reserves the following keywords for internal use:

=item C<include>
=item C<use>

=head4 Blocks

Two blocks are used internally by the grammar: C<.TOP> and C<.ANYWHERE>. The first one is a kind of global context,
where all top-level blocks and options are installed. The name can also be use in a pre-declaration to specify that
a statement can be used at the top-level:

    options => ( foo => { :in<.TOP> } )

C<.ANYWHERE> is used in pre-declaration context to keep track of pre-declared statements which do not have C<in> key
and therefore can be used literally anywhere in a config file.

Note that no keyword can start with a dot. Therefore there is no way to accidentally declare C<.TOP { }> or
C<.ANYWHERE { }>, even though technically and formally the config file looks like:

    .TOP {
        include "your-config.cfg"
    }

=head4 IDs

As it was stated in the L<Names|#Names> section any ID string starting with a dot is reserved. Use method C<autogen-id>
if you need a unique one.

=EXTENSIONS

This section provides tips for writing own grammar extensions. See
L<C<Config::BINDish::Actions>|Actions.md>
to find more about action extensions.

=head2 Context

The grammar maintains current parsing context as a way to validate various aspects of config file syntax. In this task
it relies upon:

=item C<Config::BINDish::Grammar::Context> class
=item C<$*CFG-CTX> and C<$*CFG-PARENT-CTX> variables containing instances of the C<Context> class
=item roles C<Config::BINDish::Grammar::StatementProps>, C<Config::BINDish::Grammar::ContainerProps> and classes
consuming them: C<Config::BINDish::Grammar::OptionProps> and C<Config::BINDish::Grammar::BlockProps>
=item Raku call stack

Most of the context implementation mechanics are not standardized and subject for change. Yet, a few elements are rather
unlikely to change. Among those are:

=item A context has a type, stored in the same-named attribute of the C<Context> class. The currently used types are:
I<"TOP">, I<"BLOCK">, and I<"OPTION">
=item Except for the I<"TOP"> context, all other contexts keep track of their enclosing context via C<$.parent>
attribute of the C<Context> class
=item A context's primary purpose is to provide properties of the currently begin parsed  syntax element. Those
properties are provided by C<props> attribute of the C<Context> class and expected to consume C<StatementProps> role

If you plan to implement a grammar extension with a rule or token providing own context then it'd make sense to follow
the steps taken by C«statement:sym<option>» or C«statement:sym<block>» rules.

=head2 Extending The Grammar

L<C<Config::BINDish>|../BINDish.md>
contains general information about writing extensions. Here we provide only grammar-specific details.

Only the rules and tokens documented in corresponding section above are guaranteed to be supported and not be changed
or removed without deprecation.

The most common way to extend the grammar would be to add a new kind of statement or value type. This must be as
easy as adding new rules or tokens akin to the following example:

    role MyExtension is BINDish-grammar {
        ...
        multi rule statement:sym<your-statement> {
            # Your statement syntax rules
        }
        multi token value:sym<your-type> {
            # Your value syntax rules
        }
        ...
    }

=head1 SEE ALSO

L<C<Config::BINDish>|../BINDish.md>,
L<C<Config::BINDish::Grammar::Strictness>|Grammar/Strictness.md>,
L<C<Config::BINDish::Grammar::StatementProps>|Grammar/StatementProps.md>,
L<C<Config::BINDish::Grammar::ContainerProps>|Grammar/ContainerProps.md>,
L<C<Config::BINDish::Grammar::OptionProps>|Grammar/OptionProps.md>,
L<C<Config::BINDish::Grammar::BlockProps>|Grammar/BlockProps.md>

=AUTHOR Vadim Belman <vrurg@cpan.org>

=end pod
